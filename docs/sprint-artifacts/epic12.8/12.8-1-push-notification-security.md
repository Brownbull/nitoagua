# Story 12.8-1: Push Notification Security & Logout Cleanup

| Field | Value |
|-------|-------|
| **Story ID** | 12.8-1 |
| **Epic** | Epic 12.8: Round 2 Manual Testing Bug Fixes |
| **Title** | Push Notification Security & Logout Cleanup |
| **Status** | done |
| **Priority** | P0 (Critical - Security) |
| **Points** | 8 |
| **Bug References** | BUG-R2-003, BUG-R2-017 |

## User Story

**As a** user of the NitoAgua PWA,
**I want** my push notification subscriptions to be properly cleaned up when I log out,
**So that** other users on my device don't receive my notifications (privacy protection).

## Problem Statement

### Critical Security Vulnerability

Push notifications are being sent to wrong users when accounts are switched on devices. This causes:
- **Privacy breach:** Users can see notifications about OTHER users' orders
- **Authorization bypass:** Notification links go to pages the wrong user cannot access
- **Multi-tenant isolation failure:** Cross-user data leakage

### Root Cause Analysis

**Issue 1: Missing Logout Cleanup**

When a user logs out:
- `signOut()` is called BUT `unsubscribeFromPush()` is NOT called
- Database record linking user to endpoint remains
- Browser service worker subscription stays active
- Next user who logs in inherits the old user's endpoint

**Issue 2: Database Constraint Too Loose**

Current: `UNIQUE(user_id, endpoint)` allows same endpoint for multiple users:
```
User_A → Endpoint_E1
User_B → Endpoint_E1  (ALSO ALLOWED - BUG!)
```

Should be: `UNIQUE(endpoint)` - one endpoint can only belong to one user.

**Issue 3: No Endpoint Deduplication on Subscribe**

When subscribing, the system doesn't check if the endpoint exists for a different user. It just upserts, creating duplicate endpoint associations.

### Data Flow (Bug Scenario)

```
1. Consumer A logs in on Laptop
   → Service worker gets endpoint E1
   → DB: (Consumer_A, E1)

2. Consumer A logs out
   → signOut() called
   → DB STILL HAS: (Consumer_A, E1) ← BUG!
   → Browser still subscribed to E1

3. Consumer B logs in on Laptop
   → Service worker returns endpoint E1 (device-specific)
   → upsert creates: (Consumer_B, E1)
   → DB now has BOTH: (Consumer_A, E1) AND (Consumer_B, E1)

4. Provider creates offer for Consumer A's request
   → Query: SELECT * FROM push_subscriptions WHERE user_id = Consumer_A
   → Returns: endpoint E1
   → Push sent to E1

5. E1 is currently Consumer B's browser session!
   → Notification appears on Consumer B's device
   → Consumer B sees notification meant for Consumer A
```

## Technical Context

### Files to Modify

| File | Current State | Required Change |
|------|--------------|-----------------|
| `src/app/provider/settings/sign-out-button.tsx` | Calls `signOut()` only | Add push unsubscribe before signOut |
| `src/app/consumer-profile/page.tsx` | Calls `signOut()` only | Add push unsubscribe before signOut |
| `src/components/admin/admin-logout-button.tsx` | Calls `signOut()` only | Add push unsubscribe before signOut |
| `src/lib/actions/push-subscription.ts` | Simple upsert | Add endpoint deduplication |

### Database Table

```sql
-- Current push_subscriptions table
CREATE TABLE push_subscriptions (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES profiles(id),
  endpoint TEXT NOT NULL,
  p256dh TEXT NOT NULL,
  auth TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, endpoint)  -- PROBLEM: Allows same endpoint for different users
);
```

## Acceptance Criteria

### AC12.8.1.1: Provider Logout Cleanup
**Given** a provider with an active push subscription
**When** they click "Cerrar Sesión" on the provider settings page
**Then** the push subscription is deleted from the database
**And** the browser's service worker subscription is unsubscribed
**And** then the auth signOut is performed

### AC12.8.1.2: Consumer Logout Cleanup
**Given** a consumer with an active push subscription
**When** they click "Cerrar Sesión" on the consumer profile page
**Then** the push subscription is deleted from the database
**And** the browser's service worker subscription is unsubscribed
**And** then the auth signOut is performed

### AC12.8.1.3: Admin Logout Cleanup
**Given** an admin with an active push subscription
**When** they click the logout button in the admin panel
**Then** the push subscription is deleted from the database
**And** the browser's service worker subscription is unsubscribed
**And** then the auth signOut is performed

### AC12.8.1.4: Endpoint Deduplication on Subscribe
**Given** an endpoint that is already registered for User A
**When** User B logs in on the same device and enables notifications
**Then** User A's subscription record for that endpoint is DELETED
**And** a new subscription is created for User B with that endpoint
**And** User A will NOT receive notifications on that device anymore

### AC12.8.1.5: Single User per Endpoint Guarantee
**Given** the push_subscriptions table
**When** any operation is performed
**Then** each unique endpoint can only belong to ONE user at any time
**And** queries for `endpoint = X` always return at most 1 row

### AC12.8.1.6: Graceful Logout Handling
**Given** a user who has NOT enabled push notifications
**When** they log out
**Then** the logout completes successfully without errors
**And** no push-related errors are thrown or logged

## Implementation

### Part 1: Create Logout Cleanup Utility

Create a reusable logout cleanup function:

```typescript
// src/lib/push/logout-cleanup.ts
"use client";

import { unsubscribeFromPush } from "@/lib/actions/push-subscription";

/**
 * Clean up push subscriptions before logout
 * MUST be called before supabase.auth.signOut()
 */
export async function cleanupPushBeforeLogout(): Promise<void> {
  try {
    // 1. Unsubscribe from browser push manager
    if ("serviceWorker" in navigator && "PushManager" in window) {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.getSubscription();

      if (subscription) {
        // Unsubscribe from browser
        await subscription.unsubscribe();
        console.log("[Logout] Browser push subscription removed");
      }
    }

    // 2. Delete from database (server action)
    const result = await unsubscribeFromPush();
    if (result.success) {
      console.log("[Logout] Database push subscription removed");
    }
  } catch (error) {
    // Log but don't block logout
    console.error("[Logout] Error cleaning up push subscription:", error);
  }
}
```

### Part 2: Update Provider Logout

```typescript
// src/app/provider/settings/sign-out-button.tsx
import { cleanupPushBeforeLogout } from "@/lib/push/logout-cleanup";

export function SignOutButton() {
  const [loading, setLoading] = useState(false);

  async function handleSignOut() {
    setLoading(true);
    try {
      // Clean up push FIRST
      await cleanupPushBeforeLogout();

      // Then sign out
      const supabase = createClient();
      await supabase.auth.signOut();
      router.push("/");
      router.refresh();
    } finally {
      setLoading(false);
    }
  }

  // ... rest of component
}
```

### Part 3: Update Consumer Logout

```typescript
// src/app/consumer-profile/page.tsx
import { cleanupPushBeforeLogout } from "@/lib/push/logout-cleanup";

async function handleLogout() {
  setLoggingOut(true);
  try {
    // Clean up push FIRST
    await cleanupPushBeforeLogout();

    // Then sign out
    const supabase = createClient();
    await supabase.auth.signOut();
    router.push("/");
    router.refresh();
  } finally {
    setLoggingOut(false);
  }
}
```

### Part 4: Update Admin Logout

```typescript
// src/components/admin/admin-logout-button.tsx
import { cleanupPushBeforeLogout } from "@/lib/push/logout-cleanup";

async function handleLogout() {
  setLoading(true);
  try {
    // Clean up push FIRST
    await cleanupPushBeforeLogout();

    // Then sign out
    const supabase = createClient();
    await supabase.auth.signOut();
    router.push("/");
    router.refresh();
  } finally {
    setLoading(false);
  }
}
```

### Part 5: Add Endpoint Deduplication on Subscribe

```typescript
// src/lib/actions/push-subscription.ts
export async function subscribeToPush(
  subscription: PushSubscriptionData
): Promise<SubscribeResult> {
  const supabase = await createClient();

  const { data: { user }, error: userError } = await supabase.auth.getUser();

  if (userError || !user) {
    return {
      success: false,
      error: "Tu sesión expiró. Por favor, inicia sesión nuevamente.",
      requiresLogin: true,
    };
  }

  // Validate subscription data
  if (!subscription.endpoint || !subscription.keys?.p256dh || !subscription.keys?.auth) {
    return {
      success: false,
      error: "Datos de suscripción inválidos",
    };
  }

  // NEW: Delete any existing subscriptions with same endpoint from OTHER users
  // This ensures endpoint uniqueness across all users
  const { error: dedupeError } = await supabase
    .from("push_subscriptions")
    .delete()
    .eq("endpoint", subscription.endpoint)
    .neq("user_id", user.id);

  if (dedupeError) {
    console.warn("[PushSubscription] Deduplication warning:", dedupeError);
    // Continue anyway - the upsert will still work
  }

  // Upsert for current user
  const { error: insertError } = await supabase
    .from("push_subscriptions")
    .upsert(
      {
        user_id: user.id,
        endpoint: subscription.endpoint,
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
      },
      {
        onConflict: "user_id,endpoint",
      }
    );

  if (insertError) {
    console.error("[PushSubscription] Error saving subscription:", insertError);
    return {
      success: false,
      error: "Error al guardar la suscripción",
    };
  }

  console.log(`[PushSubscription] User ${user.id} subscribed (endpoint deduplicated)`);

  return { success: true };
}
```

### Part 6: Optional - Database Migration for Global Endpoint Uniqueness

If deduplication in code is not sufficient, add a database constraint:

```sql
-- supabase/migrations/XXXXXX_add_endpoint_uniqueness.sql

-- First clean up any existing duplicates (keep only most recent per endpoint)
DELETE FROM push_subscriptions a
USING push_subscriptions b
WHERE a.endpoint = b.endpoint
  AND a.created_at < b.created_at;

-- Drop the composite unique constraint
ALTER TABLE push_subscriptions
  DROP CONSTRAINT IF EXISTS push_subscriptions_user_id_endpoint_key;

-- Add global endpoint uniqueness
ALTER TABLE push_subscriptions
  ADD CONSTRAINT push_subscriptions_endpoint_key UNIQUE (endpoint);

-- Re-add user_id constraint for fast lookups
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user_id
  ON push_subscriptions(user_id);
```

## Testing Checklist

### Manual Testing

- [ ] **Test 1: Provider Logout**
  1. Log in as provider, enable push
  2. Verify subscription in database
  3. Log out
  4. Verify subscription DELETED from database
  5. Log in as different user on same device
  6. Trigger notification for first provider
  7. Verify notification does NOT appear

- [ ] **Test 2: Consumer Logout**
  1. Log in as consumer, enable push
  2. Log out
  3. Log in as different consumer
  4. First consumer creates request, provider sends offer
  5. Verify notification goes to FIRST consumer's device, NOT this device

- [ ] **Test 3: Endpoint Deduplication**
  1. User A logs in, enables push → DB has (A, E1)
  2. User A logs out (without proper cleanup - simulate old behavior)
  3. User B logs in on same device, enables push
  4. Verify DB now has ONLY (B, E1), not both

- [ ] **Test 4: Graceful Handling**
  1. Log in as user who never enabled push
  2. Log out
  3. Verify no errors

## Definition of Done

- [ ] All logout handlers call `cleanupPushBeforeLogout()` before `signOut()`
- [ ] `subscribeToPush()` deduplicates endpoints across users
- [ ] All acceptance criteria pass manual testing
- [ ] No TypeScript errors
- [ ] Round 2 push notification tests pass
- [ ] Security: Users cannot receive other users' notifications

## Security Notes

This is a **CRITICAL SECURITY FIX**. The current behavior allows:
1. Privacy breach - seeing other users' order details
2. Authorization bypass - links to pages user cannot access
3. Multi-tenant isolation failure - cross-user data leakage

This story MUST be completed before any production deployment.

## Tasks/Subtasks

- [x] **Task 1: Create logout-cleanup utility**
  - [x] Create `src/lib/push/logout-cleanup.ts`
  - [x] Implement browser Push Manager unsubscribe
  - [x] Implement database cleanup via server action
  - [x] Add graceful error handling (AC12.8.1.6)

- [x] **Task 2: Update Provider Logout (AC12.8.1.1)**
  - [x] Import `cleanupPushBeforeLogout` in sign-out-button.tsx
  - [x] Call cleanup BEFORE signOut()

- [x] **Task 3: Update Consumer Logout (AC12.8.1.2)**
  - [x] Import `cleanupPushBeforeLogout` in consumer-profile/page.tsx
  - [x] Call cleanup BEFORE signOut()

- [x] **Task 4: Update Admin Logout (AC12.8.1.3)**
  - [x] Import `cleanupPushBeforeLogout` in admin-logout-button.tsx
  - [x] Call cleanup BEFORE signOut()

- [x] **Task 5: Add Endpoint Deduplication (AC12.8.1.4, AC12.8.1.5)**
  - [x] Modify `subscribeToPush()` in push-subscription.ts
  - [x] Delete existing subscriptions with same endpoint from OTHER users
  - [x] Use admin client for cross-user deletion (RLS bypass)

- [x] **Task 6: Validation**
  - [x] TypeScript compiles without errors
  - [x] ESLint passes on modified files
  - [x] Push subscription E2E tests pass (9/10, 1 expected skip)
  - [x] Production build succeeds

## Dev Notes

### Architecture Pattern Applied
- Used client-side utility with server action pattern (per Atlas architecture patterns)
- Admin client used for endpoint deduplication to bypass RLS

### Testing Approach
- E2E tests verify push subscription UI works
- Manual testing required for multi-user device scenario
- TypeScript + ESLint validation passed

## Dev Agent Record

### Implementation Plan
1. Create reusable logout cleanup utility
2. Update all three logout handlers (provider, consumer, admin)
3. Add endpoint deduplication to subscription flow
4. Validate with TypeScript, ESLint, and E2E tests

### Debug Log
- No blocking issues encountered
- TypeScript error fixed: Supabase select() takes single options object, not two args

### Completion Notes
- **All logout handlers** now call `cleanupPushBeforeLogout()` before `signOut()`
- **Endpoint deduplication** implemented using admin client for RLS bypass
- **Graceful handling** - errors logged but don't block logout
- **Push E2E tests:** 9/10 pass (1 expected skip for consumer dev-login)
- **Build:** Successful

## File List

### New Files
| File | Description |
|------|-------------|
| `src/lib/push/logout-cleanup.ts` | Client utility for push cleanup before logout |

### Modified Files
| File | Change |
|------|--------|
| `src/app/provider/settings/sign-out-button.tsx` | Added cleanupPushBeforeLogout() call |
| `src/app/consumer-profile/page.tsx` | Added cleanupPushBeforeLogout() call, added data-testid |
| `src/components/admin/admin-logout-button.tsx` | Added cleanupPushBeforeLogout() call, fixed Spanish accent |
| `src/lib/actions/push-subscription.ts` | Added endpoint deduplication logic |
| `tests/e2e/push-subscription.spec.ts` | Added Logout Cleanup Security E2E tests |

## Change Log

| Date | Change | Author |
|------|--------|--------|
| 2026-01-04 | Story implementation complete - all ACs satisfied | Claude AI |
| 2026-01-04 | **Code Review Fixes:** Added E2E tests for logout cleanup, added consumer logout test ID, fixed Spanish accent, added timeout to service worker ready | Claude AI (Atlas Review) |

## Code Review Record

**Review Date:** 2026-01-04
**Reviewer:** Atlas-Enhanced Code Review

### Issues Found and Fixed

| Issue | Severity | Fix Applied |
|-------|----------|-------------|
| Missing E2E tests for logout cleanup | HIGH | Added 5 new tests in `push-subscription.spec.ts` |
| Consumer logout button missing `data-testid` | MEDIUM | Added `data-testid="consumer-logout-button"` |
| `navigator.serviceWorker.ready` can hang indefinitely | MEDIUM | Added 3-second timeout wrapper in `logout-cleanup.ts` |
| Spanish text "Cerrar Sesion" missing accent | LOW | Fixed to "Cerrar Sesión" |

### Atlas Validation
- ✅ Architecture compliance (Server Actions + Admin Client pattern)
- ✅ Testing patterns (merged-fixtures, assertNoErrorState)
- ✅ User workflow chains (logout cleanup for all personas)

## Definition of Done (Verified)

- [x] All logout handlers call `cleanupPushBeforeLogout()` before `signOut()`
- [x] `subscribeToPush()` deduplicates endpoints across users
- [x] No TypeScript errors
- [x] ESLint passes
- [x] Push notification E2E tests pass (including new logout tests)
- [x] Production build succeeds
- [x] Code review completed with fixes applied
- [ ] Manual testing on multi-user device scenario (requires manual verification)
