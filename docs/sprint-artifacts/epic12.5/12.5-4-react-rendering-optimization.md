# Story 12.5-4: React Rendering Optimization

| Field | Value |
|-------|-------|
| **Story ID** | 12.5-4 |
| **Epic** | Epic 12.5: Performance Optimization |
| **Title** | React Rendering Optimization |
| **Status** | drafted |
| **Priority** | P1 (High) |
| **Points** | 5 |
| **Sprint** | Pending |

## User Story

**As a** user,
**I want** interactions to feel instant and smooth,
**So that** the app feels responsive like a native application.

## Problem Statement

Even after data loads, the app may feel sluggish due to React rendering issues:
- Excessive re-renders from context providers or state changes
- Missing memoization on expensive computations
- Inline function definitions causing unnecessary re-renders
- Large lists rendering without virtualization

## Acceptance Criteria

### AC12.5.4.1: Memoization

- [ ] Expensive computations wrapped in `useMemo`
- [ ] Callback functions stabilized with `useCallback` where needed
- [ ] Components memoized with `React.memo` where beneficial
- [ ] Document components that were optimized

**Components to Review:**
- Provider offer cards
- Request list items
- Admin order cards
- Countdown timers
- Notification items

### AC12.5.4.2: State Management

- [ ] Audit context providers for over-broadcasting
- [ ] State lifted appropriately (not causing unnecessary re-renders)
- [ ] Consider splitting large context providers if needed
- [ ] Local state preferred over global where appropriate
- [ ] Document state management changes

### AC12.5.4.3: List Rendering

- [ ] Audit lists for virtualization needs:
  - Provider offers list (`/provider/offers`)
  - Admin orders list (`/admin/orders`)
  - Request history list
  - Notification list
- [ ] Implement virtualization if lists can exceed 50 items
- [ ] Proper `key` props on all mapped elements (not index-based)
- [ ] No inline object/function definitions in render

### AC12.5.4.4: Measurement & Verification

- [ ] Re-render count reduced for key interactions
- [ ] Time to Interactive improved on key pages
- [ ] No component re-renders > 2x per user interaction
- [ ] All E2E tests pass after changes

## Tasks/Subtasks

### Task 1: Review Baseline Profiler Data
- [ ] 1.1 Review React Profiler findings from Story 12.5.1
- [ ] 1.2 Identify components with excessive re-renders
- [ ] 1.3 Prioritize by user impact

### Task 2: Memoization
- [ ] 2.1 Add useMemo for computed values
- [ ] 2.2 Add useCallback for event handlers passed as props
- [ ] 2.3 Wrap appropriate components in React.memo
- [ ] 2.4 Test that memoization is effective (profiler)

### Task 3: Context Provider Optimization
- [ ] 3.1 Audit existing context providers
- [ ] 3.2 Identify over-broadcasting issues
- [ ] 3.3 Split contexts if needed
- [ ] 3.4 Test consumer components don't re-render unnecessarily

### Task 4: List Optimization
- [ ] 4.1 Identify lists that can grow large
- [ ] 4.2 Evaluate virtualization (react-window or similar)
- [ ] 4.3 Implement if needed
- [ ] 4.4 Fix any index-based keys
- [ ] 4.5 Remove inline function definitions from maps

### Task 5: Verification
- [ ] 5.1 Re-run React Profiler on optimized flows
- [ ] 5.2 Compare before/after re-render counts
- [ ] 5.3 Run E2E tests
- [ ] 5.4 Document results

## Technical Notes

### Memoization Patterns

```typescript
// useMemo for expensive computations
const sortedOffers = useMemo(() => {
  return offers.sort((a, b) =>
    new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
  );
}, [offers]);

// useCallback for event handlers
const handleAccept = useCallback((offerId: string) => {
  acceptOffer(offerId);
}, [acceptOffer]);

// React.memo for pure components
const OfferCard = memo(function OfferCard({ offer, onAccept }: Props) {
  // component
});
```

### Context Split Pattern

```typescript
// BEFORE - Single large context
const AppContext = createContext({ user, requests, notifications, settings });

// AFTER - Split by update frequency
const UserContext = createContext({ user }); // Rarely changes
const RequestsContext = createContext({ requests }); // Changes on navigation
const NotificationsContext = createContext({ notifications }); // Real-time
```

### List Key Pattern

```typescript
// GOOD - Stable unique key
{offers.map(offer => (
  <OfferCard key={offer.id} offer={offer} />
))}

// BAD - Index as key (causes re-render issues)
{offers.map((offer, index) => (
  <OfferCard key={index} offer={offer} />
))}
```

### Avoiding Inline Definitions

```typescript
// GOOD - Stable reference
const emptyArray: Offer[] = [];
const defaultOptions = { limit: 10 };

function Component() {
  const offers = useOffers() ?? emptyArray;
  // ...
}

// BAD - New reference every render
function Component() {
  const offers = useOffers() ?? []; // New array each render
  // ...
}
```

### Virtualization Example (if needed)

```typescript
import { FixedSizeList } from 'react-window';

function OrdersList({ orders }: { orders: Order[] }) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <OrderCard order={orders[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      width="100%"
      itemCount={orders.length}
      itemSize={100}
    >
      {Row}
    </FixedSizeList>
  );
}
```

## Definition of Done

- [ ] Excessive re-renders identified and fixed
- [ ] Memoization applied where beneficial
- [ ] Context providers optimized
- [ ] Lists optimized (virtualization if needed)
- [ ] No inline definitions in renders
- [ ] Re-render count reduced for key interactions
- [ ] All E2E tests pass

## Dependencies

- **Prerequisites:** Story 12.5.1 (profiler data needed)
- **Blocks:** Story 12.5.6 (validation)
- **Can Parallel:** Stories 12.5.2, 12.5.3

## Risks

| Risk | Mitigation |
|------|------------|
| Over-memoization (complexity) | Only memoize where profiler shows benefit |
| Breaking component behavior | Test each change incrementally |
| Virtualization UX issues | Test scrolling behavior thoroughly |

---

_Story created 2025-12-28_
