# Story 12.5-3: Data Fetching Optimization

| Field | Value |
|-------|-------|
| **Story ID** | 12.5-3 |
| **Epic** | Epic 12.5: Performance Optimization |
| **Title** | Data Fetching Optimization |
| **Status** | drafted |
| **Priority** | P1 (High) |
| **Points** | 8 |
| **Sprint** | Pending |

## User Story

**As a** user,
**I want** pages to render quickly after navigation,
**So that** I don't wait for data to load before seeing content.

## Problem Statement

Slow data fetching is likely a major contributor to perceived sluggishness. Based on the tech spec, suspected issues include:
- Waterfall fetches (sequential instead of parallel)
- Over-fetching (SELECT * patterns)
- Missing database indexes
- Heavy RLS policy evaluation
- No client-side caching (re-fetching on every navigation)

## Acceptance Criteria

### AC12.5.3.1: Query Optimization

- [ ] Identify and fix queries taking > 100ms (from baseline)
- [ ] Eliminate N+1 query patterns found in audit
- [ ] Replace `SELECT *` with specific column selection
- [ ] Add missing indexes on frequently filtered columns
- [ ] Document query changes with before/after timing

**Known Filtered Columns to Check:**
- `water_requests.status`
- `water_requests.consumer_id`
- `water_requests.provider_id`
- `offers.request_id`
- `offers.provider_id`
- `offers.status`
- `profiles.role`

### AC12.5.3.2: Parallel Fetching

- [ ] Audit server components for sequential data fetches
- [ ] Convert independent fetches to parallel using `Promise.all`
- [ ] Document pages with waterfall patterns fixed
- [ ] Verify no regressions in data dependencies

**Example Pattern:**
```typescript
// BEFORE - Sequential
const user = await getUser();
const requests = await getRequests();
const notifications = await getNotifications();

// AFTER - Parallel
const [user, requests, notifications] = await Promise.all([
  getUser(),
  getRequests(),
  getNotifications()
]);
```

### AC12.5.3.3: Caching Strategy

- [ ] Evaluate client-side caching solution:
  - Option A: React Query (TanStack Query)
  - Option B: SWR
  - Option C: Next.js built-in caching
- [ ] Implement caching for non-real-time data:
  - User profile data
  - Static configuration (pricing tiers, etc.)
  - Historical data (completed requests, earnings history)
- [ ] Set appropriate cache/stale times
- [ ] Real-time data (offers, request status) remains uncached or short-lived

### AC12.5.3.4: RLS Policy Optimization

- [ ] Review RLS policies for performance
- [ ] Run `EXPLAIN ANALYZE` on key queries with RLS
- [ ] Identify expensive policy evaluations
- [ ] Optimize or restructure if overhead > 20% of query time
- [ ] Document RLS impact findings

### AC12.5.3.5: Measurement & Verification

- [ ] Average page data fetch time reduced by **≥ 40%**
- [ ] OR documented justification if < 40% achievable
- [ ] No individual API call > 500ms
- [ ] No waterfall patterns on critical pages
- [ ] All E2E tests pass after changes

## Tasks/Subtasks

### Task 1: Review Baseline Findings
- [ ] 1.1 Review slow queries from Story 12.5.1
- [ ] 1.2 Review N+1 patterns identified
- [ ] 1.3 Prioritize by impact

### Task 2: Index Optimization
- [ ] 2.1 Check existing indexes in Supabase
- [ ] 2.2 Identify missing indexes for filtered columns
- [ ] 2.3 Create migration for new indexes
- [ ] 2.4 Verify query plans improve

```sql
-- Example index migration
CREATE INDEX IF NOT EXISTS idx_water_requests_status
  ON water_requests(status);
CREATE INDEX IF NOT EXISTS idx_water_requests_consumer
  ON water_requests(consumer_id);
CREATE INDEX IF NOT EXISTS idx_offers_request_status
  ON offers(request_id, status);
```

### Task 3: Query Optimization
- [ ] 3.1 Replace SELECT * with specific columns
- [ ] 3.2 Fix N+1 patterns with proper joins
- [ ] 3.3 Test query performance improvements

### Task 4: Parallel Fetching
- [ ] 4.1 Audit server components for sequential fetches
- [ ] 4.2 Identify independent data fetches
- [ ] 4.3 Convert to Promise.all patterns
- [ ] 4.4 Verify data dependencies maintained

### Task 5: Caching Implementation
- [ ] 5.1 Evaluate caching solutions
- [ ] 5.2 Document recommendation with rationale
- [ ] 5.3 Implement chosen solution
- [ ] 5.4 Configure cache policies per data type
- [ ] 5.5 Test cache invalidation works correctly

### Task 6: RLS Review
- [ ] 6.1 Run EXPLAIN ANALYZE on slow queries
- [ ] 6.2 Identify RLS overhead
- [ ] 6.3 Optimize policies if needed
- [ ] 6.4 Document findings

### Task 7: Verification
- [ ] 7.1 Re-measure page load times
- [ ] 7.2 Compare before/after
- [ ] 7.3 Run E2E tests
- [ ] 7.4 Document results

## Technical Notes

### Supabase Query Optimization

```typescript
// BEFORE - Over-fetching
const { data } = await supabase
  .from('water_requests')
  .select('*')
  .eq('consumer_id', userId);

// AFTER - Specific columns
const { data } = await supabase
  .from('water_requests')
  .select('id, status, amount, created_at, address')
  .eq('consumer_id', userId);
```

### N+1 Pattern Fix

```typescript
// BEFORE - N+1 (fetches offers separately for each request)
const requests = await getRequests();
for (const req of requests) {
  req.offers = await getOffers(req.id);
}

// AFTER - Single query with join
const { data } = await supabase
  .from('water_requests')
  .select(`
    id, status, amount,
    offers (id, status, delivery_window_start)
  `)
  .eq('consumer_id', userId);
```

### React Query Example (if chosen)

```typescript
// Provider offers with caching
import { useQuery } from '@tanstack/react-query';

function useProviderOffers() {
  return useQuery({
    queryKey: ['provider-offers'],
    queryFn: fetchProviderOffers,
    staleTime: 30 * 1000, // 30 seconds
    cacheTime: 5 * 60 * 1000, // 5 minutes
  });
}
```

### Key Pages to Optimize

1. `/provider/dashboard` - Provider landing, multiple data types
2. `/provider/earnings` - Historical data, aggregations
3. `/admin/orders` - Large list with filters
4. `/admin/dashboard` - Multiple stats queries
5. `/request/[id]/offers` - Real-time offers list

## Definition of Done

- [ ] Slow queries (> 100ms) optimized
- [ ] N+1 patterns eliminated
- [ ] SELECT * replaced with specific columns
- [ ] Missing indexes added
- [ ] Waterfall fetches converted to parallel
- [ ] Caching strategy implemented
- [ ] RLS policies reviewed
- [ ] Fetch time reduced ≥ 40% OR justification documented
- [ ] All E2E tests pass

## Dependencies

- **Prerequisites:** Story 12.5.1 (baseline data needed)
- **Blocks:** Story 12.5.6 (validation)
- **Can Parallel:** Stories 12.5.2, 12.5.4

## Risks

| Risk | Mitigation |
|------|------------|
| Breaking data dependencies | Test each parallel conversion carefully |
| Cache staleness issues | Configure appropriate stale times |
| Index migration failures | Test on branch first |
| RLS changes affect security | Review security implications |

---

_Story created 2025-12-28_
